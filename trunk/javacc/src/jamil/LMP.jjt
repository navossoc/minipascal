/**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = false;}PARSER_BEGIN(LMP)package jamil;import java.io.*;public class LMP{  void addNode(Node n)  {    jjtree.pushNode(n);  }  public static void main(String args [])  {    // Leitura do arquivo
    InputStream in = null;    try    {      in = new FileInputStream("../samples/03.lmp");    }    catch (FileNotFoundException ex)    {      System.out.println(ex.toString());    }    // Inicializa o compilador       LMP parser = new LMP(in);    SimpleNode n = null;    try    {      n = parser.inicio();      n.dump("");      System.out.println("OK.");    }    catch (Exception e)    {      System.out.println("Not OK.");      System.out.println(e.getMessage());    }  }}PARSER_END(LMP)SKIP : /* Caracteres ignorados */{  " " // space| "\t" // tab| "\n" // line feed| "\r" // carriage return}TOKEN : /* Palavras reservadas */{  < BEGIN : "begin" >| < END : "end" >| < IF : "if" >| < THEN : "then" >| < WHILE : "while" >| < DO : "do" >}TOKEN : /* Símbolos especiais */{  /* Atribuição */  < ASSIGN : ":=" >| < SEMICOLON : ";" >  /* Lógica */| < GT : ">" >| < LT : "<" >| < EQ : "==" >| < GE : ">=" >| < LE : "<=" >  /* Expressão */| < LPAREN : "(" >| < RPAREN : ")" >  /* Operador */| < PLUS : "+" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < MOD : "MOD" >}TOKEN :{  /* Identificador */  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >  /* Número */| < NUMBER :    (< DIGIT >)+  | < DOT > (< DIGIT >)+  | (< DIGIT >)+ < DOT > (< DIGIT >)+ >| < DOT : "." >  /* ERs */| < #DIGIT : [ "0"-"9" ] >| < #LETTER : [ "a"-"z", "A"-"Z" ] >}// SemânticaSimpleNode inicio() :{}{  < BEGIN > comando() < END > < DOT >  {    return jjtThis;  }}void comando() :{}{  (    condicional()  | iterativo()  | atribuicao()  )*}void condicional() :{  Token t;  SimpleNode n;}{  t = < IF >  {    // todos os nós adicionados a árvore se tornam filho do nó anterior ao final do método,
    // isso deve servir pra criar as estrutura estilo "if" condicional "then" ......
    n = new SimpleNode(JJTCONDICIONAL);    n.jjtSetValue(t.image);    addNode(n);  }  condicao() 
  t = < THEN >  {    n = new SimpleNode(JJTCONDICIONAL);    n.jjtSetValue(t.image);    addNode(n);  }  (    LOOKAHEAD(2)    atribuicao()  )*  comando() < SEMICOLON >}void iterativo() :{}{  < WHILE > condicao() < DO >  (    LOOKAHEAD(2)    atribuicao()  )*  comando() < SEMICOLON >}void atribuicao() :{}{  identificador() < ASSIGN >  (    expressao()  | identificador()  )  (    operador()    (      expressao()    | identificador()    )  )*  < SEMICOLON >}void condicao() :{}{  identificador() logica() identificador()}void logica() :{  Token logica;}{  // TODO: acho que é o melhor que da pra chegar  (    logica = < GT >  | logica = < LT >  | logica = < EQ >  | logica = < LE >  | logica = < GE >  )  {    jjtThis.jjtSetValue(logica.image);  }}void identificador() :{  Token identificador;}{  identificador = < IDENTIFIER >  {    //identifiers.add(identificador);
    jjtThis.jjtSetValue(identificador.image);  }}void expressao() :{  Token expressao;}{  expressao = < NUMBER >  {    jjtThis.jjtSetValue(expressao.image);  }| < LPAREN > expressao() operador() expressao() < RPAREN >}void operador() :{  Token operador;}{  // TODO: muito repetitivo, pensar em algo melhor  operador = < PLUS >  {    jjtThis.jjtSetValue(operador.image);  }| operador = < MULTIPLY >  {    jjtThis.jjtSetValue(operador.image);  }| operador = < DIVIDE >  {    jjtThis.jjtSetValue(operador.image);  }| operador = < MOD >  {    jjtThis.jjtSetValue(operador.image);  }}