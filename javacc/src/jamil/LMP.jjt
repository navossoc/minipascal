/**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  NODE_CLASS = "SimpleNode2";  static = false;}PARSER_BEGIN(LMP)package jamil;import java.awt.Color;import java.awt.Dimension;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.InputStream;import javax.swing.JFrame;import org.apache.commons.collections15.Factory;import org.apache.commons.collections15.Predicate;import org.apache.commons.collections15.functors.ConstantTransformer;import edu.uci.ics.jung.algorithms.layout.TreeLayout;import edu.uci.ics.jung.graph.DelegateTree;import edu.uci.ics.jung.graph.DirectedGraph;import edu.uci.ics.jung.graph.DirectedOrderedSparseMultigraph;import edu.uci.ics.jung.graph.Graph;import edu.uci.ics.jung.graph.util.Context;import edu.uci.ics.jung.visualization.VisualizationViewer;import edu.uci.ics.jung.visualization.control.DefaultModalGraphMouse;import edu.uci.ics.jung.visualization.decorators.EdgeShape;import edu.uci.ics.jung.visualization.decorators.ToStringLabeller;import edu.uci.ics.jung.visualization.renderers.VertexLabelAsShapeRenderer;public class LMP{  // Árvore Sintática Abstrata
  int edge = 0;  DelegateTree < Node, Integer > graph;  Node tree;  public void createTree(Node node)  {    for (int i = 0; i < node.jjtGetNumChildren(); i++)    {      {        Node n = node.jjtGetChild(i);        if (n != null)        {          graph.addChild(edge++, node, n);          createTree(n);        }      }    }  }  public void drawGraph()  {    // Grafo
    Factory < DirectedGraph < Node, Integer >> factory = DirectedOrderedSparseMultigraph.< Node, Integer > getFactory();    graph = new DelegateTree < Node, Integer > (factory);    // Adiciona os vértices ao grafo    graph.addVertex(tree);    createTree(tree);    // Layout
    TreeLayout < Node, Integer > layout = new TreeLayout < Node, Integer > (graph, 80, 50);    // Visualização
    VisualizationViewer < Node, Integer > vv = new VisualizationViewer < Node, Integer > (layout, new Dimension(1280, 720));    VertexLabelAsShapeRenderer < Node, Integer > vlasr = new VertexLabelAsShapeRenderer < Node, Integer > (vv.getRenderContext());    /* Vértices */    // Cor da borda
    vv.getRenderContext().setVertexDrawPaintTransformer(new ConstantTransformer(Color.black));    // Cor de fundo
    vv.getRenderContext().setVertexFillPaintTransformer(new ConstantTransformer(Color.lightGray));    // Rótulo como string
    vv.getRenderContext().setVertexLabelTransformer(new ToStringLabeller());    // Formato retangular
    vv.getRenderContext().setVertexShapeTransformer(vlasr);    // Posiciona texto dentro
    vv.getRenderer().setVertexLabelRenderer(vlasr);    /* Arestas */    // Remove a seta da aresta
    vv.getRenderContext().setEdgeArrowPredicate(new Predicate < Context < Graph < Node, Integer >, Integer >> ()    {      @ Override public boolean evaluate(Context < Graph < Node, Integer >, Integer > arg0)      {        return false;      }    }    );    // Formato da linha
    vv.getRenderContext().setEdgeShapeTransformer(new EdgeShape.Line());    // Habilita suporte ao mouse
    final DefaultModalGraphMouse graphMouse = new DefaultModalGraphMouse();    vv.setGraphMouse(graphMouse);    // Janela do JFrame
    JFrame jf = new JFrame();    jf.getContentPane().add(vv);    jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);    jf.pack();    jf.setVisible(true);  }  private void addNode(String value)  {    jjtree.pushNode(new SimpleNode2(value));  }  public static void main(String args [])  {    // Leitura do arquivo
    InputStream in = null;    try    {      in = new FileInputStream("../samples/01.lmp");    }    catch (FileNotFoundException ex)    {      System.out.println(ex.toString());    }    // Inicializa o compilador       LMP parser = new LMP(in);    try    {      parser.tree = parser.inicio();      ((SimpleNode2) parser.tree).dump("");      System.out.println("OK.");      // Desenha o grafo na tela
      parser.drawGraph();    }    catch (Exception e)    {      System.out.println("Not OK.");      System.out.println(e.getMessage());    }  }}PARSER_END(LMP)SKIP : /* Caracteres ignorados */{  " " // space| "\t" // tab| "\n" // line feed| "\r" // carriage return}TOKEN : /* Palavras reservadas */{  < BEGIN : "begin" >| < END : "end" >| < IF : "if" >| < THEN : "then" >| < WHILE : "while" >| < DO : "do" >}TOKEN : /* Símbolos especiais */{  /* Atribuição */  < ASSIGN : ":=" >| < SEMICOLON : ";" >  /* Lógica */| < GT : ">" >| < LT : "<" >| < EQ : "==" >| < GE : ">=" >| < LE : "<=" >  /* Expressão */| < LPAREN : "(" >| < RPAREN : ")" >  /* Operador */| < PLUS : "+" >| < MULTIPLY : "*" >| < DIVIDE : "/" >| < MOD : "MOD" >}TOKEN :{  /* Identificador */  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >  /* Número */| < NUMBER :    (< DIGIT >)+  | < DOT > (< DIGIT >)+  | (< DIGIT >)+ < DOT > (< DIGIT >)+ >| < DOT : "." >  /* ERs */| < #DIGIT : [ "0"-"9" ] >| < #LETTER : [ "a"-"z", "A"-"Z" ] >}// SemânticaNode inicio() :{}{  < BEGIN >  {    addNode("begin");  }  comando() < END >  {    addNode("end");  }  < DOT >  {    addNode(".");  }  {    return jjtThis;  }}void comando() :{}{  (    condicional()  | iterativo()  | atribuicao()  )*}int condicional() :{}{  < IF >  {    addNode("if");  }  condicao() < THEN >  {    addNode("then");  }  (    LOOKAHEAD(2)    atribuicao()  )*  comando() < SEMICOLON >  {    addNode(";");  }  {    return 1;  }}int iterativo() :{}{  < WHILE >  {    addNode("while");  }  condicao()   < DO >  {    addNode("do");  }  (    LOOKAHEAD(2)    atribuicao()  )*  comando()   < SEMICOLON >  {    addNode(";");  }  {    return 2;  }}int atribuicao() :{}{  identificador() < ASSIGN >  {    addNode(":=");  }  (    expressao()  | identificador()  )  (    operador()    (      expressao()    | identificador()    )  )*  < SEMICOLON >  {    addNode(";");  }  {    return 3;  }}void condicao() :{}{  identificador() logica() identificador()}int logica() :{  Token logica;}{  (    logica = < GT >  | logica = < LT >  | logica = < EQ >  | logica = < LE >  | logica = < GE >  )  {    addNode(logica.image);  }  {    return 4;  }}int identificador() :{  Token identificador;}{  identificador = < IDENTIFIER >  {    addNode(identificador.image);  }  {    return 5;  }}int expressao() :{  Token expressao;}{  (    expressao = < NUMBER >    {      addNode(expressao.image);    }  | < LPAREN > expressao() operador() expressao() < RPAREN >  )  {}  {    return 6;  }}int operador() :{  Token operador;}{  (    operador = < PLUS >  | operador = < MULTIPLY >  | operador = < DIVIDE >  | operador = < MOD >  )  {    addNode(operador.image);  }  {    return 7;  }}